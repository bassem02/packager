package tn.wevioo.entities;
// Generated 28 mars 2017 22:31:56 by Hibernate Tools 5.2.1.Final

import static javax.persistence.GenerationType.IDENTITY;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;

import nordnet.architecture.exceptions.explicit.DataSourceException;
import nordnet.architecture.exceptions.explicit.MalformedXMLException;
import nordnet.architecture.exceptions.explicit.NotFoundException;
import nordnet.architecture.exceptions.explicit.NotRespectedRulesException;
import nordnet.architecture.exceptions.implicit.NullException;
import nordnet.architecture.exceptions.implicit.NullException.NullCases;
import nordnet.architecture.exceptions.implicit.UnsupportedActionException;
import nordnet.architecture.exceptions.utils.ErrorCode;
import nordnet.drivers.contract.exceptions.DriverException;
import nordnet.drivers.contract.types.State;
import tn.wevioo.exceptions.PackagerException;
import tn.wevioo.model.packager.action.PackagerInstanceAction;
import tn.wevioo.model.request.PackagerRequest;
import tn.wevioo.model.request.ProductRequest;
import tn.wevioo.service.PackagerActionHistoryService;
import tn.wevioo.tools.logging.AdminLogger;

/**
 * PackagerInstance generated by hbm2java
 */
@Entity
@Table(name = "packager_instance", catalog = "nn_packager_management_recette")
public class PackagerInstance implements java.io.Serializable {

	private static final Log LOGGER = LogFactory.getLog(PackagerInstance.class);

	private static final long serialVersionUID = 1L;
	private Integer idPackagerInstance;
	private PackagerModel packagerModel;
	private Retailer retailer;
	private String retailerPackagerId;
	private Date creationDate;
	private Date lastUpdate;
	private String toto;
	private Set<ProductInstance> products;

	@Transient
	public Set<ProductInstance> getProducts() {
		return products;
	}

	public void setProducts(Set<ProductInstance> products) {
		this.products = products;
	}

	private Set<ShippingDemand> shippingDemands = new HashSet<ShippingDemand>(0);
	private Set<FailedShippingDemand> failedShippingDemands = new HashSet<FailedShippingDemand>(0);
	private Set<PackagerInstanceProductInstance> packagerInstanceProductInstances = new HashSet<PackagerInstanceProductInstance>(
			0);

	public PackagerInstance() {
	}

	public PackagerInstance(PackagerModel packagerModel, Retailer retailer, String retailerPackagerId,
			Date creationDate, Date lastUpdate) {
		this.packagerModel = packagerModel;
		this.retailer = retailer;
		this.retailerPackagerId = retailerPackagerId;
		this.creationDate = creationDate;
		this.lastUpdate = lastUpdate;
	}

	public PackagerInstance(PackagerModel packagerModel, Retailer retailer, String retailerPackagerId,
			Date creationDate, Date lastUpdate, String toto, Set<ShippingDemand> shippingDemands,
			Set<FailedShippingDemand> failedShippingDemands,
			Set<PackagerInstanceProductInstance> packagerInstanceProductInstances) {
		this.packagerModel = packagerModel;
		this.retailer = retailer;
		this.retailerPackagerId = retailerPackagerId;
		this.creationDate = creationDate;
		this.lastUpdate = lastUpdate;
		this.toto = toto;
		this.shippingDemands = shippingDemands;
		this.failedShippingDemands = failedShippingDemands;
		this.packagerInstanceProductInstances = packagerInstanceProductInstances;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)

	@Column(name = "id_packager_instance", unique = true, nullable = false)
	public Integer getIdPackagerInstance() {
		return this.idPackagerInstance;
	}

	public void setIdPackagerInstance(Integer idPackagerInstance) {
		this.idPackagerInstance = idPackagerInstance;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "id_packager_model", nullable = false)
	public PackagerModel getPackagerModel() {
		return this.packagerModel;
	}

	public void setPackagerModel(PackagerModel packagerModel) {
		this.packagerModel = packagerModel;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "id_retailer", nullable = false)
	public Retailer getRetailer() {
		return this.retailer;
	}

	public void setRetailer(Retailer retailer) {
		this.retailer = retailer;
	}

	@Column(name = "retailer_packager_id", nullable = false)
	public String getRetailerPackagerId() {
		return this.retailerPackagerId;
	}

	public void setRetailerPackagerId(String retailerPackagerId) {
		this.retailerPackagerId = retailerPackagerId;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "creation_date", nullable = false, length = 19)
	public Date getCreationDate() {
		return this.creationDate;
	}

	public void setCreationDate(Date creationDate) {
		this.creationDate = creationDate;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "last_update", nullable = false, length = 19)
	public Date getLastUpdate() {
		return this.lastUpdate;
	}

	public void setLastUpdate(Date lastUpdate) {
		this.lastUpdate = lastUpdate;
	}

	@Column(name = "toto")
	public String getToto() {
		return this.toto;
	}

	public void setToto(String toto) {
		this.toto = toto;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<ShippingDemand> getShippingDemands() {
		return this.shippingDemands;
	}

	public void setShippingDemands(Set<ShippingDemand> shippingDemands) {
		this.shippingDemands = shippingDemands;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<FailedShippingDemand> getFailedShippingDemands() {
		return this.failedShippingDemands;
	}

	public void setFailedShippingDemands(Set<FailedShippingDemand> failedShippingDemands) {
		this.failedShippingDemands = failedShippingDemands;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<PackagerInstanceProductInstance> getPackagerInstanceProductInstances() {
		return this.packagerInstanceProductInstances;
	}

	public void setPackagerInstanceProductInstances(
			Set<PackagerInstanceProductInstance> packagerInstanceProductInstances) {
		this.packagerInstanceProductInstances = packagerInstanceProductInstances;
	}

	public void addProductInstance(ProductInstance productInstance) {

		if (productInstance == null) {
			throw new NullException(NullCases.NULL, "instance parameter");
		}

		if (this.products == null) {
			this.products = new HashSet<ProductInstance>();
		}

		this.products.add(productInstance);
		productInstance.setPackager(this);
	}

	@Autowired
	PackagerActionHistoryService packagerActionHistoryService;

	public void cancel(PackagerRequest request) throws NotRespectedRulesException, DriverException, NotFoundException,
			MalformedXMLException, PackagerException, DataSourceException {

		request.validate(PackagerInstanceAction.CANCEL);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.CANCEL, asList);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.CANCEL);

		if (this.packagerModel.isMultithreadedActions()) {

			/*
			 * PackagerTaskExecutor packagerTaskExecutor =
			 * (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			 * .getInstance().getBean("cancelPackagerTaskExecutor");
			 * packagerTaskExecutor.initialize(this, request, history, false);
			 * packagerTaskExecutor.execute();
			 */

		} else {
			for (ProductInstance productInstance : this.products) {
				if (!productInstance.getCurrentState().equals(State.CANCELED)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						productInstance.cancel(null, history);

					} else {
						productInstance.cancel(productRequest.getProperties(), history);

					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);

		packagerActionHistoryService.saveOrUpdate(history);

	}

	protected ProductRequest getProductRequest(PackagerRequest request, Integer productId) {
		if (request == null) {
			return null;
		}

		for (ProductRequest productRequest : request.getProducts()) {
			if (productId.equals(productRequest.getProductId())) {
				return productRequest;
			}
		}

		return null;
	}

	private List<ProductRequest> completeProductModels(List<ProductRequest> requests) throws NotFoundException {
		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest productRequest : requests) {
			if (productRequest.getModel() == null) {
				productRequest.setModel(
						this.getProductInstance(productRequest.getProductId()).getProductModel().getRetailerKey());
			}
		}

		return requests;
	}

	private void verifyProductModels(List<ProductRequest> requests)
			throws NotFoundException, NotRespectedRulesException {
		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest pr : requests) {
			if (pr.getModel() != null) {
				ProductInstance correspondingProductInstance = this.getProductInstance(pr.getProductId());

				if (!pr.getModel().equals(correspondingProductInstance.getProductModel().getRetailerKey())) {
					throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.6"));
				}

			}
		}

	}

	protected ProductInstance getProductInstance(Long productId) throws NotFoundException {
		if (productId == null) {
			throw new NullException(NullCases.NULL, "productId parameter");
		}

		for (ProductInstance productInstance : this.products) {
			if (productId.equals(productInstance.getIdProductInstance())) {
				return productInstance;
			}
		}

		throw new NotFoundException(new ErrorCode("1.2.1.3.4"));
	}

	public void suspend(PackagerRequest request) throws NotRespectedRulesException, DriverException, NotFoundException,
			MalformedXMLException, PackagerException, DataSourceException {
		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {

			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });

		}

		State packagerState = this.getCurrentState();

		if (!packagerState.equals(State.INPROGRESS) && !packagerState.equals(State.ACTIVABLE)
				&& !packagerState.equals(State.ACTIVE) && !packagerState.equals(State.DELIVERED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, "SUSPENDABLE" });
		}

		request.validate(PackagerInstanceAction.SUSPEND);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.SUSPEND, asList);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.SUSPEND);

		if (this.getPackagerModel().isMultithreadedActions()) {
			/*
			 * PackagerTaskExecutor packagerTaskExecutor =
			 * (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			 * .getInstance().getBean("suspendPackagerTaskExecutor");
			 * packagerTaskExecutor.initialize(this, request, history, false);
			 * packagerTaskExecutor.execute();
			 */
		} else {

			for (ProductInstance productInstance : this.products) {
				State productState = productInstance.getCurrentState();

				if (productState.equals(State.ACTIVABLE) || productState.equals(State.INPROGRESS)
						|| productState.equals(State.ACTIVE) || productState.equals(State.DELIVERED)) {

					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {

							productInstance.suspend(null, history);

						} catch (UnsupportedActionException e) {
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Suspend opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {

							productInstance.suspend(productRequest.getProperties(), history);

						} catch (UnsupportedActionException e) {
							if (LOGGER.isWarnEnabled()) {
							}
							LOGGER.warn("Suspend opperation not supported for productInstance ["
									+ productInstance.getIdProductInstance() + "]");
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully suspended.");
		}
	}

	@Transient
	public State getCurrentState() throws DriverException {
		List<State> productStates = new ArrayList<State>();

		for (ProductInstance productInstance : this.products) {

			productStates.add(productInstance.getCurrentState());

		}

		State packagerState = computePackagerState(productStates);

		if (packagerState != State.CANCELED && packagerState != State.UNSTABLE) {
			try {
				List<ProductRequest> requests = completeMissingExistingProducts(new ArrayList<ProductRequest>(), true);
				this.getPackagerModel().verifyProductOccurences(requests);
			} catch (PackagerException e) {
				throw new DriverException(e);
			} catch (NotRespectedRulesException e) {
				packagerState = State.UNSTABLE;
			}
		}

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "]'s current state : [" + packagerState.toString()
					+ "].");
		}

		if (packagerState.equals(State.UNSTABLE)) {
			AdminLogger.fatal("Packager Instance [" + this.retailerPackagerId + " - "
					+ this.getPackagerModel().getRetailerKey() + "] is unstable.");
		}

		return packagerState;
	}

	private List<ProductRequest> completeMissingExistingProducts(List<ProductRequest> requests, Boolean excludeCanceled)
			throws PackagerException {
		List<Long> productIdentifiers = new ArrayList<Long>();

		for (ProductRequest pr : requests) {
			productIdentifiers.add(pr.getProductId());
		}

		ProductRequest pr = null;
		for (ProductInstance pi : this.products) {
			if (!productIdentifiers.contains(pi.getIdProductInstance())) {
				try {
					if (!(excludeCanceled && pi.getCurrentState().equals(State.CANCELED))) {
						pr = new ProductRequest();
						pr.setProductId((long) pi.getIdProductInstance());
						pr.setModel(pi.getProductModel().getRetailerKey());

						requests.add(pr);
					}
				} catch (DriverException e) {
					throw new PackagerException(e);
				}
			}
		}

		return requests;
	}

	public static State computePackagerState(List<State> productInstanceStates) {

		if ((productInstanceStates == null) || (productInstanceStates.size() == 0)) {
			return State.UNSTABLE;
		}
		if (productInstanceStates.contains(null)) {
			return State.UNSTABLE;
		}
		if (productInstanceStates.contains(State.INPROGRESS)) {
			return State.INPROGRESS;
		}
		if (productInstanceStates.contains(State.ACTIVABLE)) {
			return State.ACTIVABLE;
		}
		if (productInstanceStates.contains(State.ACTIVE)) {
			return State.ACTIVE;
		}
		if (productInstanceStates.contains(State.SUSPENDED)) {
			return State.SUSPENDED;
		}
		if (productInstanceStates.contains(State.CANCELED)) {
			return State.CANCELED;
		}
		if (productInstanceStates.contains(State.DELIVERED)) {
			return State.DELIVERED;
		}

		return State.UNSTABLE;
	}
}