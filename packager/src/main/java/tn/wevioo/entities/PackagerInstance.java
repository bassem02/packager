package tn.wevioo.entities;
// Generated 28 mars 2017 22:31:56 by Hibernate Tools 5.2.1.Final

import static javax.persistence.GenerationType.IDENTITY;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.SAXException;

import nordnet.architecture.exceptions.explicit.DataSourceException;
import nordnet.architecture.exceptions.explicit.MalformedXMLException;
import nordnet.architecture.exceptions.explicit.MalformedXMLException.MalformedCases;
import nordnet.architecture.exceptions.explicit.NotFoundException;
import nordnet.architecture.exceptions.explicit.NotRespectedRulesException;
import nordnet.architecture.exceptions.implicit.NullException;
import nordnet.architecture.exceptions.implicit.NullException.NullCases;
import nordnet.architecture.exceptions.implicit.UnsupportedActionException;
import nordnet.architecture.exceptions.utils.ErrorCode;
import nordnet.drivers.contract.exceptions.DriverException;
import nordnet.drivers.contract.types.State;
import tn.wevioo.ManualDriver;
import tn.wevioo.ManualDriverFactory;
import tn.wevioo.exceptions.PackagerException;
import tn.wevioo.exceptions.RestTemplateException;
import tn.wevioo.model.feasibility.FeasibilityResult;
import tn.wevioo.model.packager.action.PackagerInstanceAction;
import tn.wevioo.model.product.action.ProductInstanceAction;
import tn.wevioo.model.request.DeliveryProperty;
import tn.wevioo.model.request.PackagerRequest;
import tn.wevioo.model.request.PackagerTransformationRequest;
import tn.wevioo.model.request.ProductRequest;
import tn.wevioo.service.PackagerActionHistoryService;
import tn.wevioo.service.PackagerInstanceService;
import tn.wevioo.service.PackagerModelService;
import tn.wevioo.service.ProductInstanceService;
import tn.wevioo.service.ProductModelProductDriverPortService;
import tn.wevioo.service.ProductModelService;
import tn.wevioo.service.WebServiceUserService;
import tn.wevioo.tools.logging.AdminLogger;
import tn.wevioo.xml.XmlMerger;

/**
 * PackagerInstance generated by hbm2java
 */
@Entity
@Table(name = "packager_instance", catalog = "nn_packager_management_recette")
public class PackagerInstance implements java.io.Serializable {

	private static final Log LOGGER = LogFactory.getLog(PackagerInstance.class);

	private static final long serialVersionUID = 1L;
	private Integer idPackagerInstance;
	private PackagerModel packagerModel;
	private Retailer retailer;
	private String retailerPackagerId;
	private Date creationDate;
	private Date lastUpdate;
	private String toto;
	private Set<ShippingDemand> shippingDemands = new HashSet<ShippingDemand>(0);
	private Set<FailedShippingDemand> failedShippingDemands = new HashSet<FailedShippingDemand>(0);
	private Set<ProductInstance> products = new HashSet<ProductInstance>(0);

	public PackagerInstance() {
	}

	@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
	@JoinTable(name = "packager_instance_product_instance", joinColumns = {
			@JoinColumn(name = "id_packager_instance", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "id_product_instance", nullable = false, updatable = false) })
	public Set<ProductInstance> getProducts() {
		return products;
	}

	public void setProducts(Set<ProductInstance> products) {
		this.products = products;
	}

	public PackagerInstance(PackagerModel packagerModel, Retailer retailer, String retailerPackagerId,
			Date creationDate, Date lastUpdate) {
		this.packagerModel = packagerModel;
		this.retailer = retailer;
		this.retailerPackagerId = retailerPackagerId;
		this.creationDate = creationDate;
		this.lastUpdate = lastUpdate;
	}

	public PackagerInstance(PackagerModel packagerModel, Retailer retailer, String retailerPackagerId,
			Date creationDate, Date lastUpdate, String toto, Set<ShippingDemand> shippingDemands,
			Set<FailedShippingDemand> failedShippingDemands) {
		this.packagerModel = packagerModel;
		this.retailer = retailer;
		this.retailerPackagerId = retailerPackagerId;
		this.creationDate = creationDate;
		this.lastUpdate = lastUpdate;
		this.toto = toto;
		this.shippingDemands = shippingDemands;
		this.failedShippingDemands = failedShippingDemands;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)

	@Column(name = "id_packager_instance", unique = true, nullable = false)
	public Integer getIdPackagerInstance() {
		return this.idPackagerInstance;
	}

	public void setIdPackagerInstance(Integer idPackagerInstance) {
		this.idPackagerInstance = idPackagerInstance;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "id_packager_model", nullable = false)
	public PackagerModel getPackagerModel() {
		return this.packagerModel;
	}

	public void setPackagerModel(PackagerModel packagerModel) {
		this.packagerModel = packagerModel;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "id_retailer", nullable = false)
	public Retailer getRetailer() {
		return this.retailer;
	}

	public void setRetailer(Retailer retailer) {
		this.retailer = retailer;
	}

	@Column(name = "retailer_packager_id", nullable = false)
	public String getRetailerPackagerId() {
		return this.retailerPackagerId;
	}

	public void setRetailerPackagerId(String retailerPackagerId) {
		this.retailerPackagerId = retailerPackagerId;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "creation_date", nullable = false, length = 19)
	public Date getCreationDate() {
		return this.creationDate;
	}

	public void setCreationDate(Date creationDate) {
		this.creationDate = creationDate;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "last_update", nullable = false, length = 19)
	public Date getLastUpdate() {
		return this.lastUpdate;
	}

	public void setLastUpdate(Date lastUpdate) {
		this.lastUpdate = lastUpdate;
	}

	@Column(name = "toto")
	public String getToto() {
		return this.toto;
	}

	public void setToto(String toto) {
		this.toto = toto;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<ShippingDemand> getShippingDemands() {
		return this.shippingDemands;
	}

	public void setShippingDemands(Set<ShippingDemand> shippingDemands) {
		this.shippingDemands = shippingDemands;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<FailedShippingDemand> getFailedShippingDemands() {
		return this.failedShippingDemands;
	}

	public void setFailedShippingDemands(Set<FailedShippingDemand> failedShippingDemands) {
		this.failedShippingDemands = failedShippingDemands;
	}

	public void addProductInstance(ProductInstance productInstance) {
		this.getProducts().add(productInstance);
	}

	protected ProductRequest getProductRequest(PackagerRequest request, Integer productId) {
		if (request == null) {
			return null;
		}

		for (ProductRequest productRequest : request.getProducts()) {
			if (productId.toString().equals(productRequest.getProductId().toString())) {
				return productRequest;
			}
		}

		return null;
	}

	private List<ProductRequest> completeProductModels(List<ProductRequest> requests) throws NotFoundException {
		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest productRequest : requests) {
			if (productRequest.getModel() == null) {
				productRequest.setModel(
						this.getProductInstance(productRequest.getProductId()).getProductModel().getRetailerKey());
			}
		}

		return requests;
	}

	private void verifyProductModels(List<ProductRequest> requests)
			throws NotFoundException, NotRespectedRulesException {
		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest pr : requests) {
			if (pr.getModel() != null) {
				ProductInstance correspondingProductInstance = this.getProductInstance(pr.getProductId());

				if (!pr.getModel().equals(correspondingProductInstance.getProductModel().getRetailerKey())) {
					throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.6"));
				}

			}
		}

	}

	protected ProductInstance getProductInstance(Long productId) throws NotFoundException {
		if (productId == null) {
			throw new NullException(NullCases.NULL, "productId parameter");
		}

		for (ProductInstance productInstance : this.getProducts()) {
			if (productId.toString().equals(productInstance.getIdProductInstance().toString())) {
				return productInstance;
			}
		}

		throw new NotFoundException(new ErrorCode("1.2.1.3.4"));
	}

	public void suspend(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException, SAXException, IOException, ParserConfigurationException,
			RestTemplateException {
		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {

			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });

		}

		State packagerState = this.getCurrentState(productInstanceService, productModelProductDriverPortService);

		if (!packagerState.equals(State.INPROGRESS) && !packagerState.equals(State.ACTIVABLE)
				&& !packagerState.equals(State.ACTIVE) && !packagerState.equals(State.DELIVERED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, "SUSPENDABLE" });
		}

		request.validate(PackagerInstanceAction.SUSPEND);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.SUSPEND, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.SUSPEND,
				webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			/*
			 * PackagerTaskExecutor packagerTaskExecutor =
			 * (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			 * .getInstance().getBean("suspendPackagerTaskExecutor");
			 * packagerTaskExecutor.initialize(this, request, history, false);
			 * packagerTaskExecutor.execute();
			 */
		} else {

			for (ProductInstance productInstance : getProducts()) {
				State productState = productInstance.getCurrentState(productModelProductDriverPortService);

				if (productState.equals(State.ACTIVABLE) || productState.equals(State.INPROGRESS)
						|| productState.equals(State.ACTIVE) || productState.equals(State.DELIVERED)) {

					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {

							productInstance.suspend(null, history, webServiceUserService, productInstanceService,
									productModelProductDriverPortService);

						} catch (UnsupportedActionException e) {
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Suspend opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {

							productInstance.suspend(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService, productModelProductDriverPortService);

						} catch (UnsupportedActionException e) {
							if (LOGGER.isWarnEnabled()) {
							}
							LOGGER.warn("Suspend opperation not supported for productInstance ["
									+ productInstance.getIdProductInstance() + "]");
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully suspended.");
		}
	}

	@Transient
	public State getCurrentState(ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws DriverException, RestTemplateException, NotFoundException {
		List<State> productStates = new ArrayList<State>();

		for (ProductInstance productInstance : getProducts()) {

			productStates.add(productInstance.getCurrentState(productModelProductDriverPortService));

		}

		State packagerState = computePackagerState(productStates);

		if (packagerState != State.CANCELED && packagerState != State.UNSTABLE) {
			try {
				List<ProductRequest> requests = completeMissingExistingProducts(new ArrayList<ProductRequest>(), true,
						productModelProductDriverPortService);
				this.getPackagerModel().verifyProductOccurences(requests);
			} catch (PackagerException e) {
				throw new DriverException(e);
			} catch (NotRespectedRulesException e) {
				packagerState = State.UNSTABLE;
			}
		}

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "]'s current state : [" + packagerState.toString()
					+ "].");
		}

		if (packagerState.equals(State.UNSTABLE)) {
			AdminLogger.fatal("Packager Instance [" + this.retailerPackagerId + " - "
					+ this.getPackagerModel().getRetailerKey() + "] is unstable.");
		}

		return packagerState;
	}

	private List<ProductRequest> completeMissingExistingProducts(List<ProductRequest> requests, Boolean excludeCanceled,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws PackagerException, RestTemplateException, NotFoundException {
		List<Long> productIdentifiers = new ArrayList<Long>();

		for (ProductRequest pr : requests) {
			productIdentifiers.add(pr.getProductId());
		}

		ProductRequest pr = null;
		for (ProductInstance pi : getProducts()) {
			if (!productIdentifiers.contains(pi.getIdProductInstance())) {
				try {
					if (!(excludeCanceled
							&& pi.getCurrentState(productModelProductDriverPortService).equals(State.CANCELED))) {
						pr = new ProductRequest();
						pr.setProductId((long) pi.getIdProductInstance());
						pr.setModel(pi.getProductModel().getRetailerKey());

						requests.add(pr);
					}
				} catch (DriverException e) {
					throw new PackagerException(e);
				}
			}
		}

		return requests;
	}

	public static State computePackagerState(List<State> productInstanceStates) {

		if ((productInstanceStates == null) || (productInstanceStates.size() == 0)) {
			return State.UNSTABLE;
		}
		if (productInstanceStates.contains(null)) {
			return State.UNSTABLE;
		}
		if (productInstanceStates.contains(State.INPROGRESS)) {
			return State.INPROGRESS;
		}
		if (productInstanceStates.contains(State.ACTIVABLE)) {
			return State.ACTIVABLE;
		}
		if (productInstanceStates.contains(State.ACTIVE)) {
			return State.ACTIVE;
		}
		if (productInstanceStates.contains(State.SUSPENDED)) {
			return State.SUSPENDED;
		}
		if (productInstanceStates.contains(State.CANCELED)) {
			return State.CANCELED;
		}
		if (productInstanceStates.contains(State.DELIVERED)) {
			return State.DELIVERED;
		}

		return State.UNSTABLE;
	}

	public void updateReferences(PackagerActionHistory packagerHistory, WebServiceUserService webServiceUserService,
			ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws DriverException, RestTemplateException, NotFoundException {

		if (packagerHistory == null) {
			throw new NullException(NullCases.NULL, "packagerHistory parameter");
		}
		if ((packagerHistory.getPackagerActionPackagerHeaderDestinations() == null
				|| packagerHistory.getPackagerActionPackagerHeaderDestinations().size() == 0)
				&& (packagerHistory.getPackagerActionPackagerHeaderSources() == null
						|| packagerHistory.getPackagerActionPackagerHeaderSources().size() == 0)) {
			packagerHistory.addDestination(this);
			packagerHistory.addSource(this);
		}

		for (ProductInstance pi : getProducts()) {
			pi.updateReferences(packagerHistory, webServiceUserService, productInstanceService,
					productModelProductDriverPortService);
		}

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "]'s references have been updated.");
		}
	}

	public void activate(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException, SAXException, IOException, ParserConfigurationException,
			RestTemplateException {
		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (!this.getCurrentState(productInstanceService, productModelProductDriverPortService)
				.equals(State.ACTIVABLE)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, State.ACTIVABLE.toString() });
		}
		request.validate(PackagerInstanceAction.ACTIVATE);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.ACTIVATE, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.ACTIVATE,
				webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("activatePackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (productInstance.getCurrentState(productModelProductDriverPortService).equals(State.ACTIVABLE)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.activate(null, history, webServiceUserService, productInstanceService,
									productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the activation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Activate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.activate(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService, productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the activation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Activate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully activated.");
		}
	}

	public void reactivate(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException, SAXException, IOException, ParserConfigurationException,
			RestTemplateException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (!this.getCurrentState(productInstanceService, productModelProductDriverPortService)
				.equals(State.SUSPENDED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, "REACTIVABLE" });
		}

		request.validate(PackagerInstanceAction.REACTIVATE);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.REACTIVATE, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.REACTIVATE,
				webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("reactivatePackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (productInstance.getCurrentState(productModelProductDriverPortService).equals(State.SUSPENDED)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.reactivate(null, history, webServiceUserService, productInstanceService,
									productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the reactivation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reactivate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.reactivate(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService, productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the reactivation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reactivate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully reactivated.");
		}
	}

	public void cancel(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException, SAXException, IOException, ParserConfigurationException,
			RestTemplateException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (this.getCurrentState(productInstanceService, productModelProductDriverPortService).equals(State.CANCELED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.19"),
					new Object[] { this.retailerPackagerId, "CANCELED" });
		}

		request.validate(PackagerInstanceAction.CANCEL);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.CANCEL, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.CANCEL, webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("cancelPackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (!productInstance.getCurrentState(productModelProductDriverPortService).equals(State.CANCELED)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.cancel(null, history, webServiceUserService, productInstanceService,
									productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the cancel action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Cancel opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.cancel(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService, productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the cancel action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Cancel opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully canceled.");
		}
	}

	public void reset(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException, SAXException, IOException, ParserConfigurationException,
			RestTemplateException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (!this.getCurrentState(productInstanceService, productModelProductDriverPortService).equals(State.ACTIVE)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, "RESETABLE" });
		}

		request.validate(PackagerInstanceAction.RESET);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.RESET, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.RESET, webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("resetPackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (productInstance.getCurrentState(productModelProductDriverPortService).equals(State.ACTIVE)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.reset(null, history, webServiceUserService, productInstanceService,
									productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the reset action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reset opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.reset(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService, productModelProductDriverPortService);
						} catch (UnsupportedActionException e) {
							// If the reset action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reset opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully reseted.");
		}
	}

	public FeasibilityResult isProductCancelationPossible(ProductRequest request,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws PackagerException, NotFoundException, RestTemplateException {

		this.getProductInstance(request.getProductId());
		List<ProductRequest> fullProductRequest = new ArrayList<ProductRequest>();
		List<ProductRequest> selectedProductRequest = new ArrayList<ProductRequest>();
		fullProductRequest = this.completeMissingExistingProducts(fullProductRequest, true,
				productModelProductDriverPortService);

		for (ProductRequest pr : fullProductRequest) {
			if (pr.getProductId() != request.getProductId()) {
				selectedProductRequest.add(pr);
			}
		}

		try {
			this.getPackagerModel().verifyProductOccurences(selectedProductRequest);
			return new FeasibilityResult(true, null, null);
		} catch (NotRespectedRulesException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		}
	}

	public void updateSelfDiagnostics(PackagerActionHistory packagerHistory,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws DriverException, RestTemplateException, NotFoundException {
		if (packagerHistory == null) {
			throw new NullException(NullCases.NULL, "packagerHistory parameter");
		}

		if (((packagerHistory.getPackagerActionPackagerHeaderDestinations() == null)
				|| (packagerHistory.getPackagerActionPackagerHeaderDestinations().size() == 0))
				&& ((packagerHistory.getPackagerActionPackagerHeaderSources() == null)
						|| (packagerHistory.getPackagerActionPackagerHeaderSources().size() == 0))) {
			packagerHistory.addSource(this);
			packagerHistory.addDestination(this);
		}

		for (ProductInstance pi : this.products) {
			pi.updateSelfDiagnostics(packagerHistory, webServiceUserService, productInstanceService,
					productModelProductDriverPortService);
		}

	}

	public void translocateProductInstances(PackagerTransformationRequest request, PackagerActionHistory history,
			PackagerInstanceService packagerInstanceService, ProductInstanceService productInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory,
			WebServiceUserService webServiceUserService,
			ProductModelProductDriverPortService productModelProductDriverPortService) throws PackagerException,
			MalformedXMLException, NotFoundException, NotRespectedRulesException, DriverException, DataSourceException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {

		request = prepareRequestForProductTranslocation(request, packagerInstanceService, productInstanceService,
				productModelService, manualDriverFactory, productModelProductDriverPortService);

		if (this.retailerPackagerId.equals(request.getRetailerPackagerId())) {
			PackagerInstance destinationPackagerInstance = packagerInstanceService
					.findByRetailerPackagerId(request.getDestinationRetailerPackagerId());

			for (ProductRequest pr : request.getChangeProductRequests()) {
				ProductInstance pi = this.getProductInstance(pr.getProductId());
				this.products.remove(pi);

				ProductInstance piClone = pi.clone();
				destinationPackagerInstance.addProductInstance(piClone);

				ProductActionHistory productHistory = new ProductActionHistory(
						ProductInstanceAction.TRANSLOCATE_PRODUCT, pi, piClone, null, webServiceUserService,
						productInstanceService);
				history.addProductAction(productHistory);

			}

			history.addSource(this);
			history.addDestination(destinationPackagerInstance);

		} else {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}
	}

	private PackagerTransformationRequest prepareRequestForProductTranslocation(PackagerTransformationRequest request,
			PackagerInstanceService packagerInstanceService, ProductInstanceService productInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory,
			ProductModelProductDriverPortService productModelProductDriverPortService) throws NotFoundException,
			PackagerException, DriverException, MalformedXMLException, NotRespectedRulesException, DataSourceException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}
		if (request.getRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "retailer packager id parameter");
		}
		if (request.getDestinationRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "detination retailer packager id parameter");
		}

		if (!(request.getRetailerPackagerId().equals(this.getRetailerPackagerId())
				|| request.getDestinationRetailerPackagerId().equals(this.getRetailerPackagerId()))) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}

		State packagerState = this.getCurrentState(productInstanceService, productModelProductDriverPortService);
		if (packagerState.equals(State.CANCELED) || packagerState.equals(State.SUSPENDED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.17"),
					new Object[] { this.retailerPackagerId, packagerState });
		}

		request.validate(PackagerInstanceAction.TRANSLOCATE_PRODUCT);

		if (this.getRetailerPackagerId().equals(request.getRetailerPackagerId())) {
			this.completeProductModels(request.getChangeProductRequests());
			PackagerInstance destinationPackagerInstance = packagerInstanceService
					.findByRetailerPackagerId(request.getDestinationRetailerPackagerId());
			destinationPackagerInstance.getPackagerModel()
					.completeDestinationProductModels(request.getChangeProductRequests());
		}

		List<ProductRequest> moveOnlyRequest = new ArrayList<ProductRequest>();
		List<ProductRequest> moveChangePropertiesRequest = new ArrayList<ProductRequest>();
		List<ProductRequest> moveTransformationRequest = new ArrayList<ProductRequest>();

		for (ProductRequest pr : request.getChangeProductRequests()) {
			ProductInstance pi = productInstanceService.findById(pr.getProductId().intValue());
			if (pi.getProductModel().getRetailerKey().equals(pr.getModel())) {
				if ((pr.getProperties() == null) || (pr.getProperties().trim().length() == 0)) {
					moveOnlyRequest.add(pr);
				} else {
					moveChangePropertiesRequest.add(pr);
				}
			} else {
				moveTransformationRequest.add(pr);
			}
		}

		if (this.getRetailerPackagerId().equals(request.getRetailerPackagerId())) {
			for (ProductRequest cpr : request.getChangeProductRequests()) {
				ProductInstance pi = productInstanceService.findById(cpr.getProductId().intValue());
				State productState = pi.getCurrentState(productModelProductDriverPortService);
				if (productState.equals(State.CANCELED) || productState.equals(State.SUSPENDED)) {
					throw new NotRespectedRulesException(new ErrorCode("1.2.2.12"),
							new Object[] { cpr.getProductId(), productState });
				}
			}
			//
			// this.mergeUserPropertiesWithExisting(moveTransformationRequest);
			// this.mergeUserPropertiesWithExisting(moveChangePropertiesRequest);

			List<ProductRequest> futureProducts = new ArrayList<ProductRequest>();
			futureProducts = this.completeMissingExistingProducts(futureProducts, true,
					productModelProductDriverPortService);
			for (ProductRequest cpr : request.getChangeProductRequests()) {
				for (ProductRequest fpr : futureProducts) {
					if (fpr.getProductId().equals(cpr.getProductId())) {
						futureProducts.remove(fpr);
						break;
					}
				}
			}
			// this.packagerModel.verifyProductOccurences(futureProducts);

			PackagerInstance destinationPackagerInstance = packagerInstanceService
					.findByRetailerPackagerId(request.getDestinationRetailerPackagerId());
			FeasibilityResult result = destinationPackagerInstance.isProductTranslocationPossible(request,
					packagerInstanceService, productInstanceService, productModelService, manualDriverFactory,
					productModelProductDriverPortService);
			if (result.getPossible()) {
				return request;
			} else {
				if (result.getExceptionCause() == null) {
					throw new PackagerException(new ErrorCode("1.2.2.27"), new Object[] { result.getMotive() });
				} else {
					throw new PackagerException(new ErrorCode("1.2.2.27"), new Object[] { result.getExceptionCause() });
				}
			}
		} else {
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.TRANSLOCATE_PRODUCT, moveTransformationRequest,
					productModelService, manualDriverFactory);
			moveTransformationRequest = this.packagerModel.mergeUserPropertiesWithDefault(moveTransformationRequest,
					false, productModelService);
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.TRANSLOCATE_PRODUCT, moveTransformationRequest,
					productModelService, manualDriverFactory);

			List<ProductRequest> fullProductRequests = new ArrayList<ProductRequest>();
			fullProductRequests.addAll(request.getChangeProductRequests());
			fullProductRequests = completeMissingExistingProducts(fullProductRequests, true,
					productModelProductDriverPortService);
			this.packagerModel.verifyProductOccurences(fullProductRequests);

			return request;
		}
	}

	public FeasibilityResult isProductTranslocationPossible(PackagerTransformationRequest request,
			PackagerInstanceService packagerInstanceService, ProductInstanceService productInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws DriverException, DataSourceException, PackagerException, SAXException, IOException,
			ParserConfigurationException, RestTemplateException, TransformerException {
		try {
			request = this.prepareRequestForProductTranslocation(request, packagerInstanceService,
					productInstanceService, productModelService, manualDriverFactory,
					productModelProductDriverPortService);
			return new FeasibilityResult(true, null, null);

		} catch (PackagerException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		} catch (NotRespectedRulesException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		} catch (NotFoundException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		} catch (MalformedXMLException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		}

	}

	public List<PackagerInstance> split(PackagerRequest source, PackagerTransformationRequest destination1,
			PackagerTransformationRequest destination2, PackagerActionHistory history,
			PackagerModelService packagerModelService, WebServiceUserService webServiceUserService,
			ProductInstanceService productInstanceService, PackagerInstanceService packagerInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory, ManualDriver manualDriver,
			ProductModelProductDriverPortService productModelProductDriverPortService) throws PackagerException,
			DataSourceException, NotRespectedRulesException, NotFoundException, MalformedXMLException, DriverException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {

		if (source == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}
		if (source.getRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "retailer packager id parameter");
		}
		if (!source.getRetailerPackagerId().equals(this.getRetailerPackagerId())) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { source.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}
		if (destination1 == null) {
			throw new NullException(NullCases.NULL, "first destination packager transformation request parameter");
		}

		List<PackagerInstance> result = new ArrayList<PackagerInstance>();
		PackagerInstance destinationPackagerInstance1 = null;
		PackagerInstance destinationPackagerInstance2 = null;

		prepareRequestsToSplit(source, destination1, destination2, packagerInstanceService, packagerModelService,
				productModelService, manualDriverFactory, productInstanceService, productModelProductDriverPortService);

		PackagerModel destinationPackagerModel1 = packagerModelService
				.findByRetailerKey(destination1.getDestinationModel());
		destinationPackagerInstance1 = destinationPackagerModel1.instantiateDestinationFromSplitMerge(destination1,
				history, productModelService, productInstanceService, webServiceUserService, manualDriverFactory,
				manualDriver, productModelProductDriverPortService);
		if (destination2 != null) {
			PackagerModel destinationPackagerModel2 = packagerModelService
					.findByRetailerKey(destination2.getDestinationModel());
			destinationPackagerInstance2 = destinationPackagerModel2.instantiateDestinationFromSplitMerge(destination2,
					history, productModelService, productInstanceService, webServiceUserService, manualDriverFactory,
					manualDriver, productModelProductDriverPortService);
		}

		for (ProductRequest pr : source.getProducts()) {
			ProductInstance pi = this.getProductInstance(pr.getProductId());
			try {
				pi.cancel(pr.getProperties(), history, webServiceUserService, productInstanceService,
						productModelProductDriverPortService);
			} catch (UnsupportedActionException e) {
				// If the cancel action is not supported the process continues
				if (LOGGER.isWarnEnabled()) {
					LOGGER.warn(
							"Cancel opperation not supported for productInstance [" + pi.getIdProductInstance() + "]");
				}
			}
		}

		result.add(destinationPackagerInstance1);

		if (destinationPackagerInstance2 != null) {
			result.add(destinationPackagerInstance2);
		}

		history.addSource(packagerInstanceService.findByRetailerPackagerId(source.getRetailerPackagerId()));
		history.addDestination(destinationPackagerInstance1);

		if (destination2 != null) {
			history.addDestination(destinationPackagerInstance2);
		}

		return result;
	}

	private void prepareRequestsToSplit(PackagerRequest source, PackagerTransformationRequest destination1,
			PackagerTransformationRequest destination2, PackagerInstanceService packagerInstanceService,
			PackagerModelService packagerModelService, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService) throws PackagerException,
			DataSourceException, NotRespectedRulesException, MalformedXMLException, NotFoundException, DriverException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {
		destination1 = prepareRequestToSplitDestination(destination1, packagerInstanceService, packagerModelService,
				productModelService, manualDriverFactory, productInstanceService, productModelProductDriverPortService);
		destination2 = prepareRequestToSplitDestination(destination2, packagerInstanceService, packagerModelService,
				productModelService, manualDriverFactory, productInstanceService, productModelProductDriverPortService);
		if (destination2 != null) {
			// verify if an existed product has been found twice on both
			// destination packager requests.
			for (ProductRequest pr : destination1.getChangeProductRequests()) {
				if (PackagerInstance.productInstanceIsFoundTwice(pr.getProductId(), destination2)) {
					throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.15"),
							new Object[] { pr.getProductId() });
				}
			}
		}
		source = prepareRequestToSplitSource(source, destination1, destination2, productModelProductDriverPortService);
	}

	private PackagerRequest prepareRequestToSplitSource(PackagerRequest source,
			PackagerTransformationRequest destination1, PackagerTransformationRequest destination2,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws PackagerException, DataSourceException, NotFoundException, MalformedXMLException,
			NotRespectedRulesException, DriverException, RestTemplateException {

		if (source == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}
		if (source.getRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "retailer packager id parameter");
		}
		if (!source.getRetailerPackagerId().equals(this.getRetailerPackagerId())) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { source.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}
		if (destination1 == null) {
			throw new NullException(NullCases.NULL, "first destination packager instance parameter");
		}

		source.validate(PackagerInstanceAction.SPLIT_SOURCE);
		// verify if an existed product has been found twice on source and on
		// destination packager request.
		for (ProductRequest pr : source.getChangeProductRequests()) {
			if (PackagerInstance.productInstanceIsFoundTwice(pr.getProductId(), destination1)) {
				throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.14"), new Object[] { pr.getProductId() });
			}
			if (PackagerInstance.productInstanceIsFoundTwice(pr.getProductId(), destination2)) {
				throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.14"), new Object[] { pr.getProductId() });
			}
		}

		List<ProductRequest> fullProductRequests = new ArrayList<ProductRequest>();
		fullProductRequests.addAll(source.getProducts());
		fullProductRequests = this.completeMissingExistingProducts(fullProductRequests, true,
				productModelProductDriverPortService);
		fullProductRequests = this.removeCanceledProductRequests(fullProductRequests,
				productModelProductDriverPortService);
		// these products will be cancelled at the end of split action
		fullProductRequests.removeAll(source.getProducts());
		// changeProductRequests from destination requests were just used to
		// compute missing products
		fullProductRequests.removeAll(destination1.getChangeProductRequests());
		if (destination2 != null) {
			// changeProductRequests from destination requests were just used to
			// compute missing products
			fullProductRequests.removeAll(destination2.getChangeProductRequests());
		}
		if (fullProductRequests.size() > 0) {
			this.packagerModel.verifyProductOccurences(fullProductRequests);
		}
		return source;
	}

	private List<ProductRequest> removeCanceledProductRequests(List<ProductRequest> requests,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws DriverException, RestTemplateException, NotFoundException {

		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		List<ProductRequest> result = new ArrayList<ProductRequest>();

		for (ProductRequest pr : requests) {
			if (pr.getProductId() == null) {
				result.add(pr);
			} else {
				for (ProductInstance pi : this.getProducts()) {
					if (pi.getIdProductInstance().toString().equals(pr.getProductId().toString())) {
						if (!pi.getCurrentState(productModelProductDriverPortService).equals(State.CANCELED)) {
							result.add(pr);
						}
					}
				}
			}
		}

		return result;
	}

	private static boolean productInstanceIsFoundTwice(Long productId, PackagerRequest packagerRequest) {
		if (packagerRequest != null) {
			for (ProductRequest pr : packagerRequest.getChangeProductRequests()) {
				if (productId.equals(pr.getProductId())) {
					return true;
				}
			}
		}
		return false;
	}

	private PackagerTransformationRequest prepareRequestToSplitDestination(PackagerTransformationRequest request,
			PackagerInstanceService packagerInstanceService, PackagerModelService packagerModelService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory,
			ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService) throws NotFoundException,
			NotRespectedRulesException, DataSourceException, DriverException, PackagerException, MalformedXMLException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {
		if (request == null) {
			return null;
		}

		if (request.getDestinationRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "destination retailer packager identifier parameter");
		}
		if (!packagerInstanceService.isRetailerPackagerIdFree(request.getDestinationRetailerPackagerId())) {
			throw new NotRespectedRulesException(new ErrorCode("0.2.1.1.9"),
					new Object[] { request.getDestinationRetailerPackagerId() });
		}

		if (request.getDestinationModel() == null) {
			throw new NullException(NullCases.NULL, "destination packager model parameter");
		}

		request.setRetailerPackagerId(this.getRetailerPackagerId());
		request.setModel(this.getPackagerModel().getRetailerKey());
		request.validate(PackagerInstanceAction.SPLIT_DESTINATION);

		PackagerModel destinationPackagerModel = packagerModelService.findByRetailerKey(request.getDestinationModel());
		// prepare change properties requests
		List<ProductRequest> changeProductRequests = this.completeProductModels(request.getChangeProductRequests());
		this.verifyProductModels(changeProductRequests);
		changeProductRequests = this.removeCanceledProductRequests(changeProductRequests,
				productModelProductDriverPortService);
		changeProductRequests = this.mergeUserPropertiesWithExisting(changeProductRequests,
				productModelProductDriverPortService);
		changeProductRequests = destinationPackagerModel.mergeUserPropertiesWithDefault(changeProductRequests, true,
				productModelService);

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.SPLIT_DESTINATION, changeProductRequests,
				productModelService, manualDriverFactory);

		// prepare create product requests
		List<ProductRequest> createProductRequests = destinationPackagerModel
				.mergeUserPropertiesWithDefault(request.getCreationProductRequests(), false, productModelService);

		createProductRequests = destinationPackagerModel
				.mergeUserPropertiesWithDefaultConfiguration(request.getCreationProductRequests(), productModelService);

		try {
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.CREATE,
					new ArrayList<ProductRequest>(request.getProducts()), productModelService, manualDriverFactory);
		} catch (MalformedXMLException e) {
			throw new MalformedXMLException(MalformedCases.INVALID_STRUCTURE, e.getMalformedXML(), e);
		}
		try {
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.CREATE, createProductRequests, productModelService,
					manualDriverFactory);
		} catch (MalformedXMLException e) {
			throw new MalformedXMLException(MalformedCases.INVALID_STRUCTURE, e.getMalformedXML(), e);
		}

		List<ProductRequest> fullProductRequests = new ArrayList<ProductRequest>();
		fullProductRequests.addAll(createProductRequests);
		fullProductRequests.addAll(changeProductRequests);
		request.setProducts(new HashSet<ProductRequest>(fullProductRequests));
		// destinationPackagerModel.verifyProductOccurences(new
		// ArrayList<ProductRequest>(request.getProducts()));
		return request;
	}

	public FeasibilityResult isSplitPossible(PackagerRequest source, PackagerTransformationRequest destination1,
			PackagerTransformationRequest destination2, PackagerInstanceService packagerInstanceService,
			PackagerModelService packagerModelService, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, ProductInstanceService productInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService) throws PackagerException,
			DataSourceException, DriverException, NotRespectedRulesException, NotFoundException, MalformedXMLException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {
		if (source == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}
		if (source.getRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "retailer packager id parameter");
		}
		if (!source.getRetailerPackagerId().equals(this.getRetailerPackagerId())) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { source.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}
		if (destination1 == null) {
			throw new NullException(NullCases.NULL, "first destination packager transformation request parameter");
		}
		try {
			destination1 = this.prepareRequestToSplitDestination(destination1, packagerInstanceService,
					packagerModelService, productModelService, manualDriverFactory, productInstanceService,
					productModelProductDriverPortService);
			destination2 = this.prepareRequestToSplitDestination(destination2, packagerInstanceService,
					packagerModelService, productModelService, manualDriverFactory, productInstanceService,
					productModelProductDriverPortService);
			this.prepareRequestToSplitSource(source, destination1, destination2, productModelProductDriverPortService);
		} catch (NotFoundException e) {
			return new FeasibilityResult(false, e.getMessage());
		} catch (NotRespectedRulesException e) {
			return new FeasibilityResult(false, e.getMessage());
		} catch (MalformedXMLException e) {
			return new FeasibilityResult(false, e.getMessage());
		}

		for (ProductRequest pr : destination1.getChangeProductRequests()) {
			ProductInstance pi = productInstanceService.findById(pr.getProductId().intValue());
			if (pr.getProperties() != null) {
				FeasibilityResult result = pi.isPropertiesChangePossible(pr.getProperties(),
						productModelProductDriverPortService);
				if (!result.getPossible()) {
					return result;
				}
			}
		}

		if (destination2 != null) {
			for (ProductRequest pr : destination2.getChangeProductRequests()) {
				ProductInstance pi = productInstanceService.findById(pr.getProductId().intValue());
				if (pr.getProperties() != null) {
					FeasibilityResult result = pi.isPropertiesChangePossible(pr.getProperties(),
							productModelProductDriverPortService);
					if (!result.getPossible()) {
						return result;
					}
				}
			}
		}

		return new FeasibilityResult(true, null);
	}

	// public void createAndSendDeliveryDemand(DeliveryRequest request, Boolean
	// reAttemptOnFailure,
	// PackagerActionHistory packagerHistory)
	// throws NotRespectedRulesException, PackagerException, DeliveryException,
	// DriverException {
	//
	// if (reAttemptOnFailure == null) {
	// throw new NullException(NullCases.NULL, "reAttemptOnFailure attribute");
	// }
	//
	// if (request == null) {
	// throw new NullException(NullCases.NULL, "request attribute");
	// }
	//
	// if (packagerHistory == null) {
	// throw new NullException(NullCases.NULL, "packagerHistory parameter");
	// }
	//
	// State packagerState = this.getCurrentState();
	// if (packagerState.equals(State.CANCELED)) {
	// throw new NotRespectedRulesException(new ErrorCode("1.2.2.17"),
	// new Object[] { this.retailerPackagerId, packagerState });
	// }
	//
	// if ((packagerHistory.getPackagerActionPackagerHeaderDestinations() ==
	// null
	// || packagerHistory.getPackagerActionPackagerHeaderDestinations().size()
	// == 0)
	// && (packagerHistory.getPackagerActionPackagerHeaderSources() == null
	// || packagerHistory.getPackagerActionPackagerHeaderSources().size() == 0))
	// {
	// packagerHistory.addDestination(this);
	// packagerHistory.addSource(this);
	// }
	//
	// ShippingDemand deliveryDemand = new ShippingDemand();
	// deliveryDemand.setCreationDate(new Date());
	// deliveryDemand.setDeclined(!request.isSendDelivery());
	//
	// if (request.isSendDelivery()) {
	// List<ShippableItemModel> deliveryReferences =
	// this.getDeliveryReferences();
	// if (deliveryReferences.size() == 0) {
	// throw new NotRespectedRulesException(new ErrorCode("1.2.2.9"),
	// new Object[] { this.retailerPackagerId });
	// }
	//
	// List<DeliveryProperty> deliveryProperties = this.getDeliveryProperties();
	// deliveryProperties.addAll(request.getProperties());
	//
	// TProperty[] netDeliveryProperties = null;
	// String[] netDeliveryReferences = null;
	// TReceiverContact netReceiverContact = null;
	// try {
	// netDeliveryProperties =
	// PackagerLogicTierBeanFactory.getDefaultConverter()
	// .convertToArray(deliveryProperties, TProperty.class);
	// netDeliveryReferences = new String[deliveryReferences.size()];
	//
	// for (int i = 0; i < deliveryReferences.size(); i++) {
	// netDeliveryReferences[i] = deliveryReferences.get(i).getReferenceName();
	// }
	//
	// netReceiverContact = request.getReceiver();
	// } catch (ConverterException e) {
	// throw new PackagerException(e);
	// }
	// String deliveryTemplate = null;
	// try {
	// if (request.getComplementaryDirective() == null
	// || request.getComplementaryDirective().trim().length() == 0) {
	// deliveryTemplate =
	// this.packagerModel.getDefaultDeliveryTemplate().getTemplateName();
	// } else {
	// deliveryTemplate =
	// this.packagerModel.getDeliveryTemplate(request.getComplementaryDirective())
	// .getTemplateName();
	// }
	// } catch (NotFoundException e) {
	// if (LOGGER.isErrorEnabled()) {
	// LOGGER.error(e.getMessage(), e);
	// }
	// throw new DeliveryException(e);
	// }
	//
	// String customerId = null;
	// if (request.getCustomerId() == null ||
	// request.getCustomerId().trim().length() == 0) {
	// customerId = "NOT_INFORMED";
	// } else {
	// customerId = request.getCustomerId();
	// }
	//
	// TShippingDemand askedDemand = null;
	// try {
	//
	// if (LOGGER.isDebugEnabled()) {
	// LOGGER.debug("Delivery Information :");
	// LOGGER.debug("---------------------------------------------");
	// LOGGER.debug("Delivery Template : " + deliveryTemplate);
	// LOGGER.debug("CustomerId : " + customerId);
	// LOGGER.debug("Receiver Contact Id : " + netReceiverContact.getId());
	// LOGGER.debug("---------------------------------------------");
	//
	// LOGGER.debug("Properties :");
	// for (TProperty property : netDeliveryProperties) {
	// LOGGER.debug(" - " + property.getName() + " / " + property.getValue());
	// }
	//
	// LOGGER.debug("---------------------------------------------");
	//
	// LOGGER.debug("References :");
	// for (String reference : netDeliveryReferences) {
	// LOGGER.debug(" - " + reference);
	// }
	// }
	//
	// askedDemand =
	// PackagerLogicTierBeanFactory.getNetDeliveryWSClient().getWebServiceClient()
	// .createShippingDemand(deliveryTemplate, customerId, netReceiverContact,
	// new TArrayOfString(netDeliveryReferences), new TArrayOfString(new
	// String[0]),
	// new TArrayOfTProperty(netDeliveryProperties));
	// } catch (Exception e) {
	// if (reAttemptOnFailure) {
	// String xmlRequest = null;
	// try {
	// xmlRequest =
	// PackagerLogicTierBeanFactory.getDeliveryJAXBTransformer().generate(request);
	// } catch (ResourceAccessException e1) {
	// throw new PackagerException(e1);
	// }
	// FailedDeliveryDemand failedDeliveryDemand = new FailedDeliveryDemand();
	// failedDeliveryDemand.setCreationDate(new Date());
	// failedDeliveryDemand.setLastAttemptDate(failedDeliveryDemand.getCreationDate());
	// failedDeliveryDemand.setXmlDeliveryRequest(xmlRequest);
	// this.addFailedDeliveryDemand(failedDeliveryDemand);
	//
	// AdminLogger.error("Created a new failed delivery demand for the packager
	// instance ["
	// + this.retailerPackagerId + "].", e);
	// throw new DeliveryException(new ErrorCode("1.2.2.24"), e);
	// } else {
	// throw new DeliveryException(new ErrorCode("0.1.1.4.5"), new Object[] {
	// "NetDelivery" }, e);
	// }
	// }
	//
	// deliveryDemand.getDeliveredProducts().addAll(this.getProducts());
	// deliveryDemand.setNetDeliveryId(askedDemand.getId());
	//
	// } else {
	//
	// if (LOGGER.isWarnEnabled()) {
	// LOGGER.warn("The delivery demand is declined.");
	// }
	// }
	//
	// this.addDeliveryDemand(deliveryDemand);
	//
	// if (LOGGER.isInfoEnabled()) {
	// LOGGER.info("The delivery demand has been successfully created.");
	// }
	// }

	@Transient
	public List<DeliveryProperty> getDeliveryProperties() {
		List<DeliveryProperty> result = new ArrayList<DeliveryProperty>();

		String packagerPrefix = "packager.";

		DeliveryProperty retailerProperty = new DeliveryProperty();
		retailerProperty.setName(packagerPrefix + "retailerPackagerId");
		retailerProperty.setValue(this.retailerPackagerId);
		result.add(retailerProperty);

		DeliveryProperty modelProperty = new DeliveryProperty();
		modelProperty.setName(packagerPrefix + "modelKey");
		modelProperty.setValue(this.packagerModel.getRetailerKey());
		result.add(modelProperty);

		int index = 0;
		for (ProductInstance pi : this.products) {

			List<DeliveryProperty> deliveryProperties = pi.getDeliveryProperties();
			for (DeliveryProperty property : deliveryProperties) {

				property.setName(property.getName().replaceAll(".null.", "." + String.valueOf(index) + "."));
				result.add(property);
			}
			index++;
		}

		return result;
	}

	@Transient
	public List<ShippableItemModel> getDeliveryReferences() {

		List<ShippableItemModel> result = new ArrayList<ShippableItemModel>();

		if (this.packagerModel.getPackagerModelShippableItemConfigurations() != null) {
			for (PackagerModelShippableItemConfiguration pdc : this.packagerModel
					.getPackagerModelShippableItemConfigurations()) {
				result.add(pdc.getShippableItemModel());
			}
		}

		for (ProductInstance pi : this.products) {
			result.addAll(pi.getDeliveryReferences());
		}

		return result;
	}

	public static PackagerInstance merge(PackagerRequest source1, PackagerRequest source2,
			PackagerTransformationRequest destination, PackagerActionHistory history,
			ManualDriverFactory manualDriverFactory, PackagerInstanceService packagerInstanceService,
			PackagerModelService packagerModelService, ProductInstanceService productInstanceService,
			WebServiceUserService webServiceUserService,
			ProductModelProductDriverPortService productModelProductDriverPortService, ManualDriver manualDriver,
			ProductModelService productModelService) throws PackagerException, DriverException, MalformedXMLException,
			NotRespectedRulesException, DataSourceException, NotFoundException, RestTemplateException, SAXException,
			IOException, ParserConfigurationException, TransformerException {

		if (source1 == null) {
			throw new NullException(NullCases.NULL, "source1 parameter");
		}
		if (source1.getRetailerPackagerId() == null || source1.getRetailerPackagerId().trim().length() == 0) {
			throw new NullException(NullCases.NULL_EMPTY, "source1 packager id parameter");
		}

		if (source2 == null) {
			throw new NullException(NullCases.NULL, "source2 parameter");
		}
		if (source2.getRetailerPackagerId() == null || source2.getRetailerPackagerId().trim().length() == 0) {
			throw new NullException(NullCases.NULL_EMPTY, "source2 packager id parameter");
		}

		if (destination == null) {
			throw new NullException(NullCases.NULL, "destination parameter");
		}

		if (destination.getDestinationRetailerPackagerId() == null
				|| destination.getDestinationRetailerPackagerId().trim().length() == 0) {
			throw new NullException(NullCases.NULL_EMPTY, "destination retailer packager id parameter");
		}

		if (!packagerInstanceService.isRetailerPackagerIdFree(destination.getDestinationRetailerPackagerId())) {
			throw new NotRespectedRulesException(new ErrorCode("0.2.1.1.9"),
					new Object[] { destination.getDestinationRetailerPackagerId() });
		}
		// preparing request
		PackagerInstance.prepareRequestsToMerge(source1, source2, destination, packagerInstanceService,
				productModelProductDriverPortService, productModelService, manualDriverFactory, packagerModelService);

		// instantiation of destination packager
		PackagerModel destinationPackagerModel = packagerModelService
				.findByRetailerKey(destination.getDestinationModel());
		PackagerInstance destinationPackagerInstance = destinationPackagerModel.instantiateDestinationFromSplitMerge(
				destination, history, productModelService, productInstanceService, webServiceUserService,
				manualDriverFactory, manualDriver, productModelProductDriverPortService);

		// canceling old products
		for (ProductRequest pr : source1.getChangeProductRequests()) {
			ProductInstance currentProduct = productInstanceService.findById(pr.getProductId().intValue());
			currentProduct.cancel(pr.getProperties(), history, webServiceUserService, productInstanceService,
					productModelProductDriverPortService);
		}

		for (ProductRequest pr : source2.getChangeProductRequests()) {
			ProductInstance currentProduct = productInstanceService.findById(pr.getProductId().intValue());
			currentProduct.cancel(pr.getProperties(), history, webServiceUserService, productInstanceService,
					productModelProductDriverPortService);
		}

		history.addSource(packagerInstanceService.findByRetailerPackagerId(source1.getRetailerPackagerId()));
		history.addSource(packagerInstanceService.findByRetailerPackagerId(source2.getRetailerPackagerId()));
		history.addDestination(destinationPackagerInstance);

		return destinationPackagerInstance;
	}

	private static void prepareRequestsToMerge(PackagerRequest source1, PackagerRequest source2,
			PackagerTransformationRequest destination, PackagerInstanceService packagerInstanceService,
			ProductModelProductDriverPortService productModelProductDriverPortService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory,
			PackagerModelService packagerModelService) throws PackagerException, NotFoundException,
			NotRespectedRulesException, DataSourceException, DriverException, MalformedXMLException,
			RestTemplateException, SAXException, IOException, ParserConfigurationException, TransformerException {
		PackagerInstance sourcePackager1 = packagerInstanceService
				.findByRetailerPackagerId(source1.getRetailerPackagerId());
		PackagerInstance sourcePackager2 = packagerInstanceService
				.findByRetailerPackagerId(source2.getRetailerPackagerId());
		source1 = sourcePackager1.prepareRequestToMergeSource(source1, destination,
				productModelProductDriverPortService);
		source2 = sourcePackager2.prepareRequestToMergeSource(source2, destination,
				productModelProductDriverPortService);
		destination = PackagerInstance.prepareRequestToMergeDestination(source1, source2, destination,
				packagerInstanceService, packagerModelService, productModelProductDriverPortService,
				productModelService, manualDriverFactory);
	}

	private static PackagerTransformationRequest prepareRequestToMergeDestination(PackagerRequest source1,
			PackagerRequest source2, PackagerTransformationRequest destination,
			PackagerInstanceService packagerInstanceService, PackagerModelService packagerModelService,
			ProductModelProductDriverPortService productModelProductDriverPortService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory) throws NotFoundException,
			NotRespectedRulesException, DataSourceException, DriverException, PackagerException, MalformedXMLException,
			SAXException, IOException, ParserConfigurationException, RestTemplateException, TransformerException {
		if (!packagerInstanceService.isRetailerPackagerIdFree(destination.getDestinationRetailerPackagerId())) {
			throw new NotRespectedRulesException(new ErrorCode("0.2.1.1.9"),
					new Object[] { destination.getDestinationRetailerPackagerId() });
		}

		destination.setRetailerPackagerId(destination.getDestinationRetailerPackagerId());
		destination.setModel(destination.getDestinationModel());
		destination.validate(PackagerInstanceAction.MERGE_DESTINATION);

		// verify if an existed product has been found twice on source and on
		// destination packager request.
		for (ProductRequest pr : destination.getChangeProductRequests()) {
			if (PackagerInstance.productInstanceIsFoundTwice(pr.getProductId(), source1)) {
				throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.14"), new Object[] { pr.getProductId() });
			}
			if (PackagerInstance.productInstanceIsFoundTwice(pr.getProductId(), source2)) {
				throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.14"), new Object[] { pr.getProductId() });
			}
		}

		PackagerModel destinationPackagerModel = packagerModelService
				.findByRetailerKey(destination.getDestinationModel());

		// dividing change product requests depending on the source

		PackagerInstance sourcePackager1 = packagerInstanceService
				.findByRetailerPackagerId(source1.getRetailerPackagerId());
		PackagerInstance sourcePackager2 = packagerInstanceService
				.findByRetailerPackagerId(source2.getRetailerPackagerId());

		List<ProductRequest> source1ChangeProductRequests = new ArrayList<ProductRequest>();
		List<ProductRequest> source2ChangeProductRequests = new ArrayList<ProductRequest>();
		for (ProductRequest pr : destination.getChangeProductRequests()) {
			try {
				sourcePackager1.getProductInstance(pr.getProductId());
				source1ChangeProductRequests.add(pr);
			} catch (NotFoundException e) {
				sourcePackager2.getProductInstance(pr.getProductId());
				source2ChangeProductRequests.add(pr);
			}
		}

		// prepare change properties requests

		source1ChangeProductRequests = sourcePackager1.completeProductModels(source1ChangeProductRequests);
		source2ChangeProductRequests = sourcePackager2.completeProductModels(source2ChangeProductRequests);

		sourcePackager1.verifyProductModels(source1ChangeProductRequests);
		sourcePackager2.verifyProductModels(source2ChangeProductRequests);

		source1ChangeProductRequests = sourcePackager1.removeCanceledProductRequests(source1ChangeProductRequests,
				productModelProductDriverPortService);
		source2ChangeProductRequests = sourcePackager2.removeCanceledProductRequests(source2ChangeProductRequests,
				productModelProductDriverPortService);

		source1ChangeProductRequests = sourcePackager1.mergeUserPropertiesWithExisting(source1ChangeProductRequests,
				productModelProductDriverPortService);
		source2ChangeProductRequests = sourcePackager2.mergeUserPropertiesWithExisting(source2ChangeProductRequests,
				productModelProductDriverPortService);

		List<ProductRequest> changeProductRequests = new ArrayList<ProductRequest>();
		changeProductRequests.addAll(source1ChangeProductRequests);
		changeProductRequests.addAll(source2ChangeProductRequests);

		changeProductRequests = destinationPackagerModel.completeDestinationProductModels(changeProductRequests);

		changeProductRequests = destinationPackagerModel.mergeUserPropertiesWithDefault(changeProductRequests, true,
				productModelService);
		PackagerModel.verifyXmlProperties(PackagerInstanceAction.MERGE_DESTINATION, changeProductRequests,
				productModelService, manualDriverFactory);

		// prepare create product requests

		List<ProductRequest> createProductRequests = destinationPackagerModel
				.mergeUserPropertiesWithDefault(destination.getCreationProductRequests(), false, productModelService);
		createProductRequests = destinationPackagerModel.mergeUserPropertiesWithDefaultConfiguration(
				destination.getCreationProductRequests(), productModelService);

		// List<ProductRequest> createProductRequests =
		// destination.getCreationProductRequests();
		// createProductRequests = destination.getCreationProductRequests();

		try {
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.CREATE,
					new ArrayList<ProductRequest>(destination.getProducts()), productModelService, manualDriverFactory);
		} catch (MalformedXMLException e) {
			throw new MalformedXMLException(MalformedCases.INVALID_STRUCTURE, e.getMalformedXML(), e);
		}
		try {
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.CREATE, createProductRequests, productModelService,
					manualDriverFactory);
		} catch (MalformedXMLException e) {
			throw new MalformedXMLException(MalformedCases.INVALID_STRUCTURE, e.getMalformedXML(), e);
		}

		List<ProductRequest> fullProductRequests = new ArrayList<ProductRequest>();
		fullProductRequests.addAll(createProductRequests);
		fullProductRequests.addAll(changeProductRequests);
		destination.setProducts(new HashSet<ProductRequest>(fullProductRequests));
		destinationPackagerModel.verifyProductOccurences(new ArrayList<ProductRequest>(destination.getProducts()));
		return destination;
	}

	public List<ProductRequest> mergeUserPropertiesWithExisting(List<ProductRequest> productRequests,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws NotFoundException, MalformedXMLException, NotRespectedRulesException, DriverException,
			ParserConfigurationException, SAXException, IOException, TransformerException, RestTemplateException {

		if (productRequests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest pr : productRequests) {
			ProductInstance pi = this.getProductInstance(pr.getProductId());
			pr.setProperties(
					XmlMerger.merge(pr.getProperties(), pi.getProductProperties(productModelProductDriverPortService)));

			if (LOGGER.isDebugEnabled()) {
				LOGGER.debug("Merged properties:\n" + pr.getProperties());
			}
		}

		return productRequests;
	}

	private PackagerRequest prepareRequestToMergeSource(PackagerRequest source,
			PackagerTransformationRequest destination,
			ProductModelProductDriverPortService productModelProductDriverPortService)
			throws PackagerException, DriverException, DataSourceException, MalformedXMLException, NotFoundException,
			NotRespectedRulesException, RestTemplateException {
		source.validate(PackagerInstanceAction.MERGE_SOURCE);
		List<ProductRequest> fullProductRequests = new ArrayList<ProductRequest>();
		fullProductRequests.addAll(source.getProducts());
		fullProductRequests = this.completeMissingExistingProducts(fullProductRequests, true,
				productModelProductDriverPortService);
		fullProductRequests = this.removeCanceledProductRequests(fullProductRequests,
				productModelProductDriverPortService);
		// these products will be cancelled at the end of merge action
		fullProductRequests.removeAll(source.getProducts());
		// changeProductRequests from destination requests were just used to
		// compute missing products
		fullProductRequests.removeAll(destination.getChangeProductRequests());
		if (fullProductRequests.size() > 0) {
			this.packagerModel.verifyProductOccurences(fullProductRequests);
		}
		return source;
	}

}