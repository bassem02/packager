package tn.wevioo.entities;
// Generated 28 mars 2017 22:31:56 by Hibernate Tools 5.2.1.Final

import static javax.persistence.GenerationType.IDENTITY;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.JoinTable;
import javax.persistence.ManyToMany;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import nordnet.architecture.exceptions.explicit.DataSourceException;
import nordnet.architecture.exceptions.explicit.MalformedXMLException;
import nordnet.architecture.exceptions.explicit.NotFoundException;
import nordnet.architecture.exceptions.explicit.NotRespectedRulesException;
import nordnet.architecture.exceptions.implicit.NullException;
import nordnet.architecture.exceptions.implicit.NullException.NullCases;
import nordnet.architecture.exceptions.implicit.UnsupportedActionException;
import nordnet.architecture.exceptions.utils.ErrorCode;
import nordnet.drivers.contract.exceptions.DriverException;
import nordnet.drivers.contract.types.State;
import tn.wevioo.ManualDriverFactory;
import tn.wevioo.exceptions.PackagerException;
import tn.wevioo.feasibility.FeasibilityResult;
import tn.wevioo.model.packager.action.PackagerInstanceAction;
import tn.wevioo.model.product.action.ProductInstanceAction;
import tn.wevioo.model.request.PackagerRequest;
import tn.wevioo.model.request.PackagerTransformationRequest;
import tn.wevioo.model.request.ProductRequest;
import tn.wevioo.service.PackagerActionHistoryService;
import tn.wevioo.service.PackagerInstanceService;
import tn.wevioo.service.ProductInstanceService;
import tn.wevioo.service.ProductModelService;
import tn.wevioo.service.WebServiceUserService;
import tn.wevioo.tools.logging.AdminLogger;

/**
 * PackagerInstance generated by hbm2java
 */
@Entity
@Table(name = "packager_instance", catalog = "nn_packager_management_recette")
public class PackagerInstance implements java.io.Serializable {

	private static final Log LOGGER = LogFactory.getLog(PackagerInstance.class);

	private static final long serialVersionUID = 1L;
	private Integer idPackagerInstance;
	private PackagerModel packagerModel;
	private Retailer retailer;
	private String retailerPackagerId;
	private Date creationDate;
	private Date lastUpdate;
	private String toto;
	private Set<ShippingDemand> shippingDemands = new HashSet<ShippingDemand>(0);
	private Set<FailedShippingDemand> failedShippingDemands = new HashSet<FailedShippingDemand>(0);
	private Set<ProductInstance> products = new HashSet<ProductInstance>(0);

	public PackagerInstance() {
	}

	@ManyToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
	@JoinTable(name = "packager_instance_product_instance", joinColumns = {
			@JoinColumn(name = "id_packager_instance", nullable = false, updatable = false) }, inverseJoinColumns = {
					@JoinColumn(name = "id_product_instance", nullable = false, updatable = false) })
	public Set<ProductInstance> getProducts() {
		return products;
	}

	public void setProducts(Set<ProductInstance> products) {
		this.products = products;
	}

	public PackagerInstance(PackagerModel packagerModel, Retailer retailer, String retailerPackagerId,
			Date creationDate, Date lastUpdate) {
		this.packagerModel = packagerModel;
		this.retailer = retailer;
		this.retailerPackagerId = retailerPackagerId;
		this.creationDate = creationDate;
		this.lastUpdate = lastUpdate;
	}

	public PackagerInstance(PackagerModel packagerModel, Retailer retailer, String retailerPackagerId,
			Date creationDate, Date lastUpdate, String toto, Set<ShippingDemand> shippingDemands,
			Set<FailedShippingDemand> failedShippingDemands) {
		this.packagerModel = packagerModel;
		this.retailer = retailer;
		this.retailerPackagerId = retailerPackagerId;
		this.creationDate = creationDate;
		this.lastUpdate = lastUpdate;
		this.toto = toto;
		this.shippingDemands = shippingDemands;
		this.failedShippingDemands = failedShippingDemands;
	}

	@Id
	@GeneratedValue(strategy = IDENTITY)

	@Column(name = "id_packager_instance", unique = true, nullable = false)
	public Integer getIdPackagerInstance() {
		return this.idPackagerInstance;
	}

	public void setIdPackagerInstance(Integer idPackagerInstance) {
		this.idPackagerInstance = idPackagerInstance;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "id_packager_model", nullable = false)
	public PackagerModel getPackagerModel() {
		return this.packagerModel;
	}

	public void setPackagerModel(PackagerModel packagerModel) {
		this.packagerModel = packagerModel;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "id_retailer", nullable = false)
	public Retailer getRetailer() {
		return this.retailer;
	}

	public void setRetailer(Retailer retailer) {
		this.retailer = retailer;
	}

	@Column(name = "retailer_packager_id", nullable = false)
	public String getRetailerPackagerId() {
		return this.retailerPackagerId;
	}

	public void setRetailerPackagerId(String retailerPackagerId) {
		this.retailerPackagerId = retailerPackagerId;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "creation_date", nullable = false, length = 19)
	public Date getCreationDate() {
		return this.creationDate;
	}

	public void setCreationDate(Date creationDate) {
		this.creationDate = creationDate;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = "last_update", nullable = false, length = 19)
	public Date getLastUpdate() {
		return this.lastUpdate;
	}

	public void setLastUpdate(Date lastUpdate) {
		this.lastUpdate = lastUpdate;
	}

	@Column(name = "toto")
	public String getToto() {
		return this.toto;
	}

	public void setToto(String toto) {
		this.toto = toto;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<ShippingDemand> getShippingDemands() {
		return this.shippingDemands;
	}

	public void setShippingDemands(Set<ShippingDemand> shippingDemands) {
		this.shippingDemands = shippingDemands;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "packagerInstance")
	public Set<FailedShippingDemand> getFailedShippingDemands() {
		return this.failedShippingDemands;
	}

	public void setFailedShippingDemands(Set<FailedShippingDemand> failedShippingDemands) {
		this.failedShippingDemands = failedShippingDemands;
	}

	public void addProductInstance(ProductInstance productInstance) {
		this.products.add(productInstance);
	}

	protected ProductRequest getProductRequest(PackagerRequest request, Integer productId) {
		if (request == null) {
			return null;
		}

		for (ProductRequest productRequest : request.getProducts()) {
			if (productId.toString().equals(productRequest.getProductId().toString())) {
				return productRequest;
			}
		}

		return null;
	}

	private List<ProductRequest> completeProductModels(List<ProductRequest> requests) throws NotFoundException {
		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest productRequest : requests) {
			if (productRequest.getModel() == null) {
				productRequest.setModel(
						this.getProductInstance(productRequest.getProductId()).getProductModel().getRetailerKey());
			}
		}

		return requests;
	}

	private void verifyProductModels(List<ProductRequest> requests)
			throws NotFoundException, NotRespectedRulesException {
		if (requests == null) {
			throw new NullException(NullCases.NULL, "requests parameter");
		}

		for (ProductRequest pr : requests) {
			if (pr.getModel() != null) {
				ProductInstance correspondingProductInstance = this.getProductInstance(pr.getProductId());

				if (!pr.getModel().equals(correspondingProductInstance.getProductModel().getRetailerKey())) {
					throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.6"));
				}

			}
		}

	}

	protected ProductInstance getProductInstance(Long productId) throws NotFoundException {
		if (productId == null) {
			throw new NullException(NullCases.NULL, "productId parameter");
		}

		for (ProductInstance productInstance : this.getProducts()) {
			if (productId.toString().equals(productInstance.getIdProductInstance().toString())) {
				return productInstance;
			}
		}

		throw new NotFoundException(new ErrorCode("1.2.1.3.4"));
	}

	public void suspend(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException {
		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {

			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });

		}

		State packagerState = this.getCurrentState();

		// if (!packagerState.equals(State.INPROGRESS) &&
		// !packagerState.equals(State.ACTIVABLE)
		// && !packagerState.equals(State.ACTIVE) &&
		// !packagerState.equals(State.DELIVERED)) {
		// throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
		// new Object[] { this.retailerPackagerId, "SUSPENDABLE" });
		// }

		request.validate(PackagerInstanceAction.SUSPEND);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.SUSPEND, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.SUSPEND,
				webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			/*
			 * PackagerTaskExecutor packagerTaskExecutor =
			 * (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			 * .getInstance().getBean("suspendPackagerTaskExecutor");
			 * packagerTaskExecutor.initialize(this, request, history, false);
			 * packagerTaskExecutor.execute();
			 */
		} else {

			for (ProductInstance productInstance : getProducts()) {
				State productState = productInstance.getCurrentState();

				if (productState.equals(State.ACTIVABLE) || productState.equals(State.INPROGRESS)
						|| productState.equals(State.ACTIVE) || productState.equals(State.DELIVERED)) {

					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {

							productInstance.suspend(null, history, webServiceUserService, productInstanceService);

						} catch (UnsupportedActionException e) {
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Suspend opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {

							productInstance.suspend(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService);

						} catch (UnsupportedActionException e) {
							if (LOGGER.isWarnEnabled()) {
							}
							LOGGER.warn("Suspend opperation not supported for productInstance ["
									+ productInstance.getIdProductInstance() + "]");
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully suspended.");
		}
	}

	@Transient
	public State getCurrentState() throws DriverException {
		List<State> productStates = new ArrayList<State>();

		for (ProductInstance productInstance : getProducts()) {

			productStates.add(productInstance.getCurrentState());

		}

		State packagerState = computePackagerState(productStates);

		if (packagerState != State.CANCELED && packagerState != State.UNSTABLE) {
			try {
				List<ProductRequest> requests = completeMissingExistingProducts(new ArrayList<ProductRequest>(), true);
				this.getPackagerModel().verifyProductOccurences(requests);
			} catch (PackagerException e) {
				throw new DriverException(e);
			} catch (NotRespectedRulesException e) {
				packagerState = State.UNSTABLE;
			}
		}

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "]'s current state : [" + packagerState.toString()
					+ "].");
		}

		if (packagerState.equals(State.UNSTABLE)) {
			AdminLogger.fatal("Packager Instance [" + this.retailerPackagerId + " - "
					+ this.getPackagerModel().getRetailerKey() + "] is unstable.");
		}

		return packagerState;
	}

	private List<ProductRequest> completeMissingExistingProducts(List<ProductRequest> requests, Boolean excludeCanceled)
			throws PackagerException {
		List<Long> productIdentifiers = new ArrayList<Long>();

		for (ProductRequest pr : requests) {
			productIdentifiers.add(pr.getProductId());
		}

		ProductRequest pr = null;
		for (ProductInstance pi : getProducts()) {
			if (!productIdentifiers.contains(pi.getIdProductInstance())) {
				try {
					if (!(excludeCanceled && pi.getCurrentState().equals(State.CANCELED))) {
						pr = new ProductRequest();
						pr.setProductId((long) pi.getIdProductInstance());
						pr.setModel(pi.getProductModel().getRetailerKey());

						requests.add(pr);
					}
				} catch (DriverException e) {
					throw new PackagerException(e);
				}
			}
		}

		return requests;
	}

	public static State computePackagerState(List<State> productInstanceStates) {

		if ((productInstanceStates == null) || (productInstanceStates.size() == 0)) {
			return State.UNSTABLE;
		}
		if (productInstanceStates.contains(null)) {
			return State.UNSTABLE;
		}
		if (productInstanceStates.contains(State.INPROGRESS)) {
			return State.INPROGRESS;
		}
		if (productInstanceStates.contains(State.ACTIVABLE)) {
			return State.ACTIVABLE;
		}
		if (productInstanceStates.contains(State.ACTIVE)) {
			return State.ACTIVE;
		}
		if (productInstanceStates.contains(State.SUSPENDED)) {
			return State.SUSPENDED;
		}
		if (productInstanceStates.contains(State.CANCELED)) {
			return State.CANCELED;
		}
		if (productInstanceStates.contains(State.DELIVERED)) {
			return State.DELIVERED;
		}

		return State.UNSTABLE;
	}

	public void updateReferences(PackagerActionHistory packagerHistory, WebServiceUserService webServiceUserService,
			ProductInstanceService productInstanceService) throws DriverException {

		if (packagerHistory == null) {
			throw new NullException(NullCases.NULL, "packagerHistory parameter");
		}
		if ((packagerHistory.getPackagerActionPackagerHeaderDestinations() == null
				|| packagerHistory.getPackagerActionPackagerHeaderDestinations().size() == 0)
				&& (packagerHistory.getPackagerActionPackagerHeaderSources() == null
						|| packagerHistory.getPackagerActionPackagerHeaderSources().size() == 0)) {
			packagerHistory.addDestination(this);
			packagerHistory.addSource(this);
		}

		for (ProductInstance pi : getProducts()) {
			pi.updateReferences(packagerHistory, webServiceUserService, productInstanceService);
		}

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "]'s references have been updated.");
		}
	}

	public void activate(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException {
		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (!this.getCurrentState().equals(State.ACTIVABLE)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, State.ACTIVABLE.toString() });
		}
		request.validate(PackagerInstanceAction.ACTIVATE);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.ACTIVATE, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.ACTIVATE,
				webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("activatePackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (productInstance.getCurrentState().equals(State.ACTIVABLE)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.activate(null, history, webServiceUserService, productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the activation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Activate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.activate(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the activation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Activate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully activated.");
		}
	}

	public void reactivate(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (!this.getCurrentState().equals(State.SUSPENDED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, "REACTIVABLE" });
		}

		request.validate(PackagerInstanceAction.REACTIVATE);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.REACTIVATE, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.REACTIVATE,
				webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("reactivatePackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (productInstance.getCurrentState().equals(State.SUSPENDED)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.reactivate(null, history, webServiceUserService, productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the reactivation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reactivate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.reactivate(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the reactivation action is not supported the
							// process continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reactivate opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully reactivated.");
		}
	}

	public void cancel(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (this.getCurrentState().equals(State.CANCELED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.19"),
					new Object[] { this.retailerPackagerId, "CANCELED" });
		}

		request.validate(PackagerInstanceAction.CANCEL);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.CANCEL, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.CANCEL, webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("cancelPackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (!productInstance.getCurrentState().equals(State.CANCELED)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.cancel(null, history, webServiceUserService, productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the cancel action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Cancel opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.cancel(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the cancel action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Cancel opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully canceled.");
		}
	}

	public void reset(PackagerRequest request, ProductModelService productModelService,
			ManualDriverFactory manualDriverFactory, PackagerActionHistoryService packagerActionHistoryService,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService)
			throws NotRespectedRulesException, DriverException, NotFoundException, MalformedXMLException,
			PackagerException, DataSourceException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}

		if (!request.getRetailerPackagerId().equals(this.retailerPackagerId)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.retailerPackagerId });
		}

		if (!this.getCurrentState().equals(State.ACTIVE)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.18"),
					new Object[] { this.retailerPackagerId, "RESETABLE" });
		}

		request.validate(PackagerInstanceAction.RESET);
		List<ProductRequest> asList = new ArrayList<ProductRequest>(request.getProducts());
		verifyProductModels(asList);
		asList = completeProductModels(asList);
		request.setProducts(new HashSet<ProductRequest>(asList));

		PackagerModel.verifyXmlProperties(PackagerInstanceAction.RESET, asList, productModelService,
				manualDriverFactory);

		PackagerActionHistory history = new PackagerActionHistory(PackagerInstanceAction.RESET, webServiceUserService);

		if (this.getPackagerModel().isMultithreadedActions()) {
			// PackagerTaskExecutor packagerTaskExecutor =
			// (PackagerTaskExecutor) PackagerLogicTierBeanFactory
			// .getInstance().getBean("resetPackagerTaskExecutor");
			// packagerTaskExecutor.initialize(this, request, history, false);
			// packagerTaskExecutor.execute();
		} else {
			for (ProductInstance productInstance : this.products) {
				if (productInstance.getCurrentState().equals(State.ACTIVE)) {
					ProductRequest productRequest = this.getProductRequest(request,
							productInstance.getIdProductInstance());

					if (productRequest == null) {
						try {
							productInstance.reset(null, history, webServiceUserService, productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the reset action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reset opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					} else {
						try {
							productInstance.reset(productRequest.getProperties(), history, webServiceUserService,
									productInstanceService);
						} catch (UnsupportedActionException e) {
							// If the reset action is not supported the process
							// continues
							if (LOGGER.isWarnEnabled()) {
								LOGGER.warn("Reset opperation not supported for productInstance ["
										+ productInstance.getIdProductInstance() + "]");
							}
						}
					}
				}
			}
		}

		history.addSource(this);
		history.addDestination(this);
		history.setLastUpdate(new Date());

		packagerActionHistoryService.saveOrUpdate(history);

		if (LOGGER.isInfoEnabled()) {
			LOGGER.info("Packager [" + this.getRetailerPackagerId() + "] has been successfully reseted.");
		}
	}

	public FeasibilityResult isProductCancelationPossible(ProductRequest request)
			throws PackagerException, NotFoundException {

		this.getProductInstance(request.getProductId());
		List<ProductRequest> fullProductRequest = new ArrayList<ProductRequest>();
		List<ProductRequest> selectedProductRequest = new ArrayList<ProductRequest>();
		fullProductRequest = this.completeMissingExistingProducts(fullProductRequest, true);

		for (ProductRequest pr : fullProductRequest) {
			if (pr.getProductId() != request.getProductId()) {
				selectedProductRequest.add(pr);
			}
		}

		try {
			this.getPackagerModel().verifyProductOccurences(selectedProductRequest);
			return new FeasibilityResult(true, null, null);
		} catch (NotRespectedRulesException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		}
	}

	public void updateSelfDiagnostics(PackagerActionHistory packagerHistory,
			WebServiceUserService webServiceUserService, ProductInstanceService productInstanceService)
			throws DriverException {
		if (packagerHistory == null) {
			throw new NullException(NullCases.NULL, "packagerHistory parameter");
		}

		if (((packagerHistory.getPackagerActionPackagerHeaderDestinations() == null)
				|| (packagerHistory.getPackagerActionPackagerHeaderDestinations().size() == 0))
				&& ((packagerHistory.getPackagerActionPackagerHeaderSources() == null)
						|| (packagerHistory.getPackagerActionPackagerHeaderSources().size() == 0))) {
			packagerHistory.addSource(this);
			packagerHistory.addDestination(this);
		}

		for (ProductInstance pi : this.products) {
			pi.updateSelfDiagnostics(packagerHistory, webServiceUserService, productInstanceService);
		}

	}

	public void translocateProductInstances(PackagerTransformationRequest request, PackagerActionHistory history,
			PackagerInstanceService packagerInstanceService, ProductInstanceService productInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory,
			WebServiceUserService webServiceUserService) throws PackagerException, MalformedXMLException,
			NotFoundException, NotRespectedRulesException, DriverException, DataSourceException {

		request = prepareRequestForProductTranslocation(request, packagerInstanceService, productInstanceService,
				productModelService, manualDriverFactory);

		if (this.retailerPackagerId.equals(request.getRetailerPackagerId())) {
			PackagerInstance destinationPackagerInstance = packagerInstanceService
					.findByRetailerPackagerId(request.getDestinationRetailerPackagerId());

			for (ProductRequest pr : request.getChangeProductRequests()) {
				ProductInstance pi = this.getProductInstance(pr.getProductId());
				this.products.remove(pi);

				ProductInstance piClone = pi.clone();
				destinationPackagerInstance.addProductInstance(piClone);

				ProductActionHistory productHistory = new ProductActionHistory(
						ProductInstanceAction.TRANSLOCATE_PRODUCT, pi, piClone, null, webServiceUserService,
						productInstanceService);
				history.addProductAction(productHistory);

			}

			history.addSource(this);
			history.addDestination(destinationPackagerInstance);

		} else {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}
	}

	private PackagerTransformationRequest prepareRequestForProductTranslocation(PackagerTransformationRequest request,
			PackagerInstanceService packagerInstanceService, ProductInstanceService productInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory) throws NotFoundException,
			PackagerException, DriverException, MalformedXMLException, NotRespectedRulesException, DataSourceException {

		if (request == null) {
			throw new NullException(NullCases.NULL, "request parameter");
		}
		if (request.getRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "retailer packager id parameter");
		}
		if (request.getDestinationRetailerPackagerId() == null) {
			throw new NullException(NullCases.NULL, "detination retailer packager id parameter");
		}

		if (!(request.getRetailerPackagerId().equals(this.getRetailerPackagerId())
				|| request.getDestinationRetailerPackagerId().equals(this.getRetailerPackagerId()))) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.1.1.9"),
					new Object[] { request.getRetailerPackagerId(), this.getRetailerPackagerId() });
		}

		State packagerState = this.getCurrentState();
		if (packagerState.equals(State.CANCELED) || packagerState.equals(State.SUSPENDED)) {
			throw new NotRespectedRulesException(new ErrorCode("1.2.2.17"),
					new Object[] { this.retailerPackagerId, packagerState });
		}

		request.validate(PackagerInstanceAction.TRANSLOCATE_PRODUCT);

		if (this.getRetailerPackagerId().equals(request.getRetailerPackagerId())) {
			this.completeProductModels(request.getChangeProductRequests());
			PackagerInstance destinationPackagerInstance = packagerInstanceService
					.findByRetailerPackagerId(request.getDestinationRetailerPackagerId());
			destinationPackagerInstance.getPackagerModel()
					.completeDestinationProductModels(request.getChangeProductRequests());
		}

		List<ProductRequest> moveOnlyRequest = new ArrayList<ProductRequest>();
		List<ProductRequest> moveChangePropertiesRequest = new ArrayList<ProductRequest>();
		List<ProductRequest> moveTransformationRequest = new ArrayList<ProductRequest>();

		for (ProductRequest pr : request.getChangeProductRequests()) {
			ProductInstance pi = productInstanceService.findById(pr.getProductId().intValue());
			if (pi.getProductModel().getRetailerKey().equals(pr.getModel())) {
				if ((pr.getProperties() == null) || (pr.getProperties().trim().length() == 0)) {
					moveOnlyRequest.add(pr);
				} else {
					moveChangePropertiesRequest.add(pr);
				}
			} else {
				moveTransformationRequest.add(pr);
			}
		}

		if (this.getRetailerPackagerId().equals(request.getRetailerPackagerId())) {
			for (ProductRequest cpr : request.getChangeProductRequests()) {
				ProductInstance pi = productInstanceService.findById(cpr.getProductId().intValue());
				State productState = pi.getCurrentState();
				if (productState.equals(State.CANCELED) || productState.equals(State.SUSPENDED)) {
					throw new NotRespectedRulesException(new ErrorCode("1.2.2.12"),
							new Object[] { cpr.getProductId(), productState });
				}
			}
			//
			// this.mergeUserPropertiesWithExisting(moveTransformationRequest);
			// this.mergeUserPropertiesWithExisting(moveChangePropertiesRequest);

			List<ProductRequest> futureProducts = new ArrayList<ProductRequest>();
			futureProducts = this.completeMissingExistingProducts(futureProducts, true);
			for (ProductRequest cpr : request.getChangeProductRequests()) {
				for (ProductRequest fpr : futureProducts) {
					if (fpr.getProductId().equals(cpr.getProductId())) {
						futureProducts.remove(fpr);
						break;
					}
				}
			}
			this.packagerModel.verifyProductOccurences(futureProducts);

			PackagerInstance destinationPackagerInstance = packagerInstanceService
					.findByRetailerPackagerId(request.getDestinationRetailerPackagerId());
			FeasibilityResult result = destinationPackagerInstance.isProductTranslocationPossible(request,
					packagerInstanceService, productInstanceService, productModelService, manualDriverFactory);
			if (result.getPossible()) {
				return request;
			} else {
				if (result.getExceptionCause() == null) {
					throw new PackagerException(new ErrorCode("1.2.2.27"), new Object[] { result.getMotive() });
				} else {
					throw new PackagerException(new ErrorCode("1.2.2.27"), new Object[] { result.getExceptionCause() });
				}
			}
		} else {
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.TRANSLOCATE_PRODUCT, moveTransformationRequest,
					productModelService, manualDriverFactory);
			// moveTransformationRequest =
			// this.packagerModel.mergeUserPropertiesWithDefault(moveTransformationRequest,
			// false);
			PackagerModel.verifyXmlProperties(PackagerInstanceAction.TRANSLOCATE_PRODUCT, moveTransformationRequest,
					productModelService, manualDriverFactory);

			List<ProductRequest> fullProductRequests = new ArrayList<ProductRequest>();
			fullProductRequests.addAll(request.getChangeProductRequests());
			fullProductRequests = completeMissingExistingProducts(fullProductRequests, true);
			this.packagerModel.verifyProductOccurences(fullProductRequests);

			return request;
		}
	}

	public FeasibilityResult isProductTranslocationPossible(PackagerTransformationRequest request,
			PackagerInstanceService packagerInstanceService, ProductInstanceService productInstanceService,
			ProductModelService productModelService, ManualDriverFactory manualDriverFactory)
			throws PackagerException, DriverException, DataSourceException {
		try {
			request = this.prepareRequestForProductTranslocation(request, packagerInstanceService,
					productInstanceService, productModelService, manualDriverFactory);
			return new FeasibilityResult(true, null, null);
		} catch (NotRespectedRulesException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		} catch (NotFoundException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		} catch (MalformedXMLException e) {
			return new FeasibilityResult(false, e.getMessage(), e);
		}

	}

}